import { DASTVulnerability, ProofOfConcept, DASTEvidence, CrawledEndpoint } from '../../types/dast';

export class VulnerabilityVerifier {
  private sessionToken: string;
  private baseUrl: string;
  private corsProxy: string = 'https://cors-anywhere.herokuapp.com/';

  constructor(baseUrl: string, sessionToken: string) {
    this.baseUrl = baseUrl;
    this.sessionToken = sessionToken;
  }

  async verifyVulnerability(
    endpoint: CrawledEndpoint,
    payload: string,
    expectedVulnType: string
  ): Promise<DASTVulnerability | null> {
    console.log(`üîç Verifying ${expectedVulnType} vulnerability at ${endpoint.url}`);

    try {
      // Step 1: Execute the payload
      const testResult = await this.executePayload(endpoint, payload);
      
      // Step 2: Analyze response for vulnerability indicators
      const vulnerabilityDetected = await this.analyzeResponse(testResult, expectedVulnType);
      
      if (!vulnerabilityDetected) {
        return null;
      }

      // Step 3: Generate proof of concept
      const proofOfConcept = await this.generateProofOfConcept(endpoint, payload, testResult);
      
      // Step 4: Collect evidence
      const evidence = await this.collectEvidence(endpoint, payload, testResult);
      
      // Step 5: Calculate risk score
      const cvssScore = this.calculateCVSSScore(expectedVulnType, endpoint, testResult);
      
      // Step 6: Create vulnerability object
      const vulnerability: DASTVulnerability = {
        id: `vuln-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        scanId: 'current-scan', // This would be passed in
        type: expectedVulnType as any,
        severity: this.determineSeverity(cvssScore),
        title: this.generateVulnerabilityTitle(expectedVulnType, endpoint),
        description: this.generateVulnerabilityDescription(expectedVulnType, endpoint, payload),
        endpoint: endpoint.url,
        parameter: this.extractParameterFromPayload(endpoint, payload),
        payload,
        evidence,
        proofOfConcept,
        cvssScore,
        cweId: this.getCWEId(expectedVulnType),
        owaspCategory: this.getOWASPCategory(expectedVulnType),
        businessImpact: this.assessBusinessImpact(expectedVulnType, endpoint),
        remediation: this.generateRemediationAdvice(expectedVulnType, endpoint),
        verificationStatus: 'verified',
        discoveredAt: new Date()
      };

      console.log(`‚úÖ Verified ${expectedVulnType} vulnerability: ${vulnerability.title}`);
      return vulnerability;

    } catch (error) {
      console.error(`‚ùå Verification failed for ${expectedVulnType}:`, error);
      return null;
    }
  }

  private async executePayload(endpoint: CrawledEndpoint, payload: string): Promise<any> {
    const testUrl = this.constructTestUrl(endpoint, payload);
    const testBody = this.constructTestBody(endpoint, payload);
    const testHeaders = this.constructTestHeaders(endpoint);

    const startTime = Date.now();
    
    try {
      // Route through CORS proxy for Salesforce API calls
      const proxiedUrl = testUrl.includes(this.baseUrl) ? `${this.corsProxy}${testUrl}` : testUrl;
      
      const response = await fetch(proxiedUrl, {
        method: endpoint.method,
        headers: testHeaders,
        body: testBody
      });

      const endTime = Date.now();
      const responseBody = await response.text();

      return {
        request: {
          url: testUrl,
          method: endpoint.method,
          headers: testHeaders,
          body: testBody,
          timestamp: new Date(startTime)
        },
        response: {
          status: response.status,
          statusText: response.statusText,
          headers: Object.fromEntries(response.headers.entries()),
          body: responseBody,
          timestamp: new Date(endTime),
          responseTime: endTime - startTime
        }
      };

    } catch (error) {
      return {
        request: {
          url: testUrl,
          method: endpoint.method,
          headers: testHeaders,
          body: testBody,
          timestamp: new Date(startTime)
        },
        error: error.message,
        timestamp: new Date()
      };
    }
  }

  private async analyzeResponse(testResult: any, vulnType: string): Promise<boolean> {
    const response = testResult.response;
    
    if (!response) {
      return false;
    }

    switch (vulnType) {
      case 'soql_injection':
        return this.detectSOQLInjection(response);
      
      case 'xss_reflected':
      case 'xss_stored':
        return this.detectXSS(response);
      
      case 'auth_bypass':
        return this.detectAuthBypass(response);
      
      case 'session_fixation':
        return this.detectSessionFixation(response);
      
      case 'business_logic_flaw':
        return this.detectBusinessLogicFlaw(response);
      
      case 'api_security_flaw':
        return this.detectAPISecurityFlaw(response);
      
      default:
        return false;
    }
  }

  private detectSOQLInjection(response: any): boolean {
    const body = response.body.toLowerCase();
    
    // Check for SOQL error messages
    const soqlErrorPatterns = [
      'invalid soql',
      'soql syntax error',
      'unexpected token',
      'line 1, column',
      'select count() from',
      'malformed query',
      'invalid field',
      'no such column'
    ];

    const hasSOQLError = soqlErrorPatterns.some(pattern => body.includes(pattern));
    
    // Check for successful injection indicators
    const injectionIndicators = [
      'system administrator',
      'user records found',
      'account records',
      'contact records'
    ];

    const hasInjectionSuccess = injectionIndicators.some(indicator => body.includes(indicator));
    
    // Check response time (for time-based injection)
    const hasTimeDelay = response.responseTime > 5000;

    return hasSOQLError || hasInjectionSuccess || hasTimeDelay;
  }

  private detectXSS(response: any): boolean {
    const body = response.body;
    
    // Check if payload is reflected in response
    const xssPatterns = [
      '<script>',
      'javascript:',
      'onerror=',
      'onload=',
      'alert(',
      'confirm(',
      'prompt('
    ];

    return xssPatterns.some(pattern => body.includes(pattern));
  }

  private detectAuthBypass(response: any): boolean {
    // Check for successful authentication bypass
    const successIndicators = [
      response.status === 200 && response.body.includes('dashboard'),
      response.status === 302 && response.headers.location?.includes('home'),
      response.body.includes('welcome'),
      response.body.includes('logout'),
      response.headers['set-cookie']?.includes('session')
    ];

    return successIndicators.some(indicator => indicator);
  }

  private detectSessionFixation(response: any): boolean {
    const setCookieHeader = response.headers['set-cookie'];
    
    if (!setCookieHeader) {
      return false;
    }

    // Check if session ID is predictable or not properly regenerated
    return setCookieHeader.includes('sessionid=') && 
           !setCookieHeader.includes('Secure') &&
           !setCookieHeader.includes('HttpOnly');
  }

  private detectBusinessLogicFlaw(response: any): boolean {
    // Check for business logic bypass indicators
    const bypassIndicators = [
      response.body.includes('workflow bypassed'),
      response.body.includes('validation skipped'),
      response.body.includes('approval not required'),
      response.status === 200 && response.body.includes('success')
    ];

    return bypassIndicators.some(indicator => indicator);
  }

  private detectAPISecurityFlaw(response: any): boolean {
    // Check for API security issues
    const securityFlaws = [
      response.headers['access-control-allow-origin'] === '*',
      !response.headers['x-content-type-options'],
      !response.headers['x-frame-options'],
      response.body.includes('internal server error'),
      response.body.includes('stack trace')
    ];

    return securityFlaws.some(flaw => flaw);
  }

  private async generateProofOfConcept(
    endpoint: CrawledEndpoint,
    payload: string,
    testResult: any
  ): Promise<ProofOfConcept> {
    const steps = [
      `Navigate to ${endpoint.url}`,
      `Inject payload: ${payload}`,
      `Observe response for vulnerability indicators`,
      `Confirm exploitation success`
    ];

    return {
      steps,
      payload,
      expectedResult: 'Vulnerability should be triggered',
      actualResult: this.summarizeTestResult(testResult),
      reproducible: true,
      automatedTest: this.generateAutomatedTest(endpoint, payload)
    };
  }

  private async collectEvidence(
    endpoint: CrawledEndpoint,
    payload: string,
    testResult: any
  ): Promise<DASTEvidence[]> {
    const evidence: DASTEvidence[] = [];

    // HTTP Request Evidence
    evidence.push({
      type: 'request',
      content: JSON.stringify(testResult.request, null, 2),
      timestamp: new Date(),
      metadata: {
        method: endpoint.method,
        url: endpoint.url,
        payload
      }
    });

    // HTTP Response Evidence
    evidence.push({
      type: 'response',
      content: JSON.stringify(testResult.response, null, 2),
      timestamp: new Date(),
      metadata: {
        status: testResult.response?.status,
        responseTime: testResult.response?.responseTime
      }
    });

    // Screenshot Evidence (simulated)
    if (endpoint.pageType !== 'api') {
      evidence.push({
        type: 'screenshot',
        content: 'base64-encoded-screenshot-data',
        timestamp: new Date(),
        metadata: {
          pageType: endpoint.pageType,
          vulnerability: 'confirmed'
        }
      });
    }

    return evidence;
  }

  private calculateCVSSScore(vulnType: string, endpoint: CrawledEndpoint, testResult: any): number {
    // Simplified CVSS calculation
    let baseScore = 0;

    switch (vulnType) {
      case 'soql_injection':
        baseScore = 9.0; // Critical
        break;
      case 'xss_reflected':
        baseScore = 6.1; // Medium
        break;
      case 'xss_stored':
        baseScore = 7.2; // High
        break;
      case 'auth_bypass':
        baseScore = 9.8; // Critical
        break;
      case 'session_fixation':
        baseScore = 7.5; // High
        break;
      case 'business_logic_flaw':
        baseScore = 5.3; // Medium
        break;
      default:
        baseScore = 4.0; // Low
    }

    // Adjust based on context
    if (endpoint.pageType === 'api') {
      baseScore += 0.5; // APIs are often more critical
    }

    if (testResult.response?.body?.includes('admin')) {
      baseScore += 1.0; // Admin access increases severity
    }

    return Math.min(baseScore, 10.0);
  }

  private determineSeverity(cvssScore: number): 'critical' | 'high' | 'medium' | 'low' | 'info' {
    if (cvssScore >= 9.0) return 'critical';
    if (cvssScore >= 7.0) return 'high';
    if (cvssScore >= 4.0) return 'medium';
    if (cvssScore >= 0.1) return 'low';
    return 'info';
  }

  private generateVulnerabilityTitle(vulnType: string, endpoint: CrawledEndpoint): string {
    const typeMap: Record<string, string> = {
      'soql_injection': 'SOQL Injection',
      'xss_reflected': 'Reflected Cross-Site Scripting (XSS)',
      'xss_stored': 'Stored Cross-Site Scripting (XSS)',
      'auth_bypass': 'Authentication Bypass',
      'session_fixation': 'Session Fixation',
      'business_logic_flaw': 'Business Logic Flaw'
    };

    return `${typeMap[vulnType] || vulnType} in ${endpoint.pageType} at ${endpoint.url}`;
  }

  private generateVulnerabilityDescription(vulnType: string, endpoint: CrawledEndpoint, payload: string): string {
    return `A ${vulnType} vulnerability was discovered in the ${endpoint.pageType} endpoint at ${endpoint.url}. The vulnerability can be exploited using the payload: ${payload}`;
  }

  private extractParameterFromPayload(endpoint: CrawledEndpoint, payload: string): string | undefined {
    // Find which parameter was used for the payload
    return endpoint.parameters.find(p => payload.includes(p.name))?.name;
  }

  private getCWEId(vulnType: string): string | undefined {
    const cweMap: Record<string, string> = {
      'soql_injection': 'CWE-89',
      'xss_reflected': 'CWE-79',
      'xss_stored': 'CWE-79',
      'auth_bypass': 'CWE-287',
      'session_fixation': 'CWE-384'
    };

    return cweMap[vulnType];
  }

  private getOWASPCategory(vulnType: string): string | undefined {
    const owaspMap: Record<string, string> = {
      'soql_injection': 'A03:2021 ‚Äì Injection',
      'xss_reflected': 'A07:2021 ‚Äì Cross-Site Scripting',
      'xss_stored': 'A07:2021 ‚Äì Cross-Site Scripting',
      'auth_bypass': 'A07:2021 ‚Äì Identification and Authentication Failures'
    };

    return owaspMap[vulnType];
  }

  private assessBusinessImpact(vulnType: string, endpoint: CrawledEndpoint): string {
    const impactMap: Record<string, string> = {
      'soql_injection': 'Complete database compromise, unauthorized data access, potential data exfiltration',
      'xss_reflected': 'Session hijacking, credential theft, malicious content injection',
      'xss_stored': 'Persistent malicious content, widespread user compromise',
      'auth_bypass': 'Unauthorized system access, privilege escalation, complete account takeover'
    };

    return impactMap[vulnType] || 'Security vulnerability that may compromise system integrity';
  }

  private generateRemediationAdvice(vulnType: string, endpoint: CrawledEndpoint): string {
    const remediationMap: Record<string, string> = {
      'soql_injection': 'Use parameterized queries, implement input validation, apply principle of least privilege',
      'xss_reflected': 'Implement output encoding, use Content Security Policy, validate and sanitize input',
      'xss_stored': 'Implement output encoding, input validation, and Content Security Policy',
      'auth_bypass': 'Implement proper authentication mechanisms, use secure session management'
    };

    return remediationMap[vulnType] || 'Implement appropriate security controls to mitigate this vulnerability';
  }

  private summarizeTestResult(testResult: any): string {
    if (testResult.error) {
      return `Request failed with error: ${testResult.error}`;
    }

    return `Response status: ${testResult.response?.status}, Response time: ${testResult.response?.responseTime}ms`;
  }

  private generateAutomatedTest(endpoint: CrawledEndpoint, payload: string): string {
    return `
// Automated test for vulnerability verification
const testPayload = "${payload}";
const testUrl = "${endpoint.url}";
const testMethod = "${endpoint.method}";

// Execute test and verify vulnerability
const result = await executeVulnerabilityTest(testUrl, testMethod, testPayload);
assert(result.vulnerable === true, "Vulnerability should be detected");
    `.trim();
  }

  // Helper methods for URL and body construction
  private constructTestUrl(endpoint: CrawledEndpoint, payload: string): string {
    let url = endpoint.url.startsWith('http') ? endpoint.url : `${this.baseUrl}${endpoint.url}`;
    
    // Inject payload into URL parameters if applicable
    const urlParams = endpoint.parameters.filter(p => p.type === 'query');
    if (urlParams.length > 0) {
      const params = new URLSearchParams();
      urlParams.forEach(param => {
        params.set(param.name, param.name === 'test' ? payload : param.value);
      });
      url += `?${params.toString()}`;
    }
    
    return url;
  }

  private constructTestBody(endpoint: CrawledEndpoint, payload: string): string | undefined {
    const bodyParams = endpoint.parameters.filter(p => p.type === 'body');
    
    if (bodyParams.length === 0) {
      return undefined;
    }

    const body: Record<string, any> = {};
    bodyParams.forEach(param => {
      body[param.name] = param.name === 'test' ? payload : param.value;
    });

    return JSON.stringify(body);
  }

  private constructTestHeaders(endpoint: CrawledEndpoint): Record<string, string> {
    const headers: Record<string, string> = {
      'Authorization': `Bearer ${this.sessionToken}`,
      'Content-Type': 'application/json',
      'User-Agent': 'SecureForce-Pro-DAST/1.0',
      'X-Requested-With': 'XMLHttpRequest'
    };

    // Add any endpoint-specific headers
    Object.assign(headers, endpoint.headers);

    return headers;
  }
}